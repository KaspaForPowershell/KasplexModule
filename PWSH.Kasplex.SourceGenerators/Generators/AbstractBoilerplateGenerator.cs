namespace PWSH.Kasplex.SourceGenerators.Generators;

public abstract class AbstractBoilerplateGenerator
    :
    IIncrementalGenerator
{
    protected readonly string _attributeNamespace = "PWSH.Kasplex.SourceGenerators.Attributes";
    protected readonly string _attributeName;
    protected readonly string _attributeFileName;

    protected readonly Dictionary<string, uint> COUNT_PER_FILE = [];

/* -----------------------------------------------------------------
CONSTRUCTORS                                                       |
----------------------------------------------------------------- */

    public AbstractBoilerplateGenerator(string attribute_name)
    {
        this._attributeName = attribute_name;
        this._attributeFileName = $"{this._attributeNamespace}.{this._attributeName}";
    }

/* -----------------------------------------------------------------
HELPERS                                                            |
----------------------------------------------------------------- */

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider
        (
            predicate: static (node, _) => IsSyntaxTarget(node),
            transform: (gtx, _) => GetSymanticTarget(gtx)
        )
        .Where(static target => target is not null);

        context.RegisterSourceOutput(provider, (ctx, source) => Execute(ctx, source));
        context.RegisterPostInitializationOutput(ctx => PostInitializationOutput(ctx));
    }

    protected static bool IsSyntaxTarget(SyntaxNode node)
        =>
        node is ClassDeclarationSyntax classNode &&
        classNode.AttributeLists.Count > 0 &&
        classNode.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));

    protected DataContainer? GetSymanticTarget(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);
        var attributeSymbol = context.SemanticModel.Compilation.GetTypeByMetadataName(this._attributeFileName);

        if (classSymbol is null || attributeSymbol is null) return null;

        foreach (var data in classSymbol.GetAttributes())
        {
            if (!attributeSymbol.Equals(data.AttributeClass, SymbolEqualityComparer.Default)) continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = GetFullMetadataName(classSymbol);

#pragma warning disable IDE0037 // Use inferred member name.
            var properties = classSymbol.GetMembers()
                        .OfType<IPropertySymbol>()
                        .Where(p => p.DeclaredAccessibility == Accessibility.Public)
                        .Select(p => (p.Name, Type: p.Type.ToDisplayString()))
                        .ToList();
#pragma warning restore IDE0037 // Use inferred member name.

            return new DataContainer(namespaceName, className, properties);
        }

        return null;
    }

    protected void Execute(SourceProductionContext context, DataContainer? data_container)
    {
        if (data_container is null) return;

        var namespaceName = data_container.NamespaceName;
        var className = data_container.ClassName;
        var fileName = $"{namespaceName}.{className}.g.cs";

        if (!COUNT_PER_FILE.ContainsKey(fileName)) COUNT_PER_FILE.Add(fileName, 0);
        COUNT_PER_FILE[fileName]++;

        var builder = new StringBuilder()
            .AppendLine("// <auto-generated />")
            .AppendLine($"// Generation count: {COUNT_PER_FILE[fileName]}")
            .AppendLine("#nullable enable")
            .AppendLine()
            .Append($"namespace {namespaceName};").AppendLine()
            .AppendLine();

        var nestedClassNames = className.Split('.');
        EmitNestedClassBoilerplate(builder, nestedClassNames, [.. data_container.PropertyInfos]);

        context.AddSource(fileName, builder.ToString());
    }

    protected void PostInitializationOutput(IncrementalGeneratorPostInitializationContext context)
    {
        var builder = new StringBuilder()
            .Append($"namespace {this._attributeNamespace};").AppendLine()
            .AppendLine()
            .Append("[AttributeUsage(AttributeTargets.Class)]").AppendLine()
            .Append($"internal class {this._attributeName}").AppendLine()
            .AppendIndent(1).Append(":").AppendLine()
            .AppendIndent(1).Append("System.Attribute {}");

        context.AddSource
        (
            $"{this._attributeFileName}.g.cs",
            builder.ToString()
        );
    }

    protected static string GetFullMetadataName(INamedTypeSymbol type_symbol)
    {
        var parts = new Stack<string>();
        ISymbol? current = type_symbol;

        while (current is INamedTypeSymbol namedType)
        {
            parts.Push(namedType.Name);
            current = namedType.ContainingType;
        }

        if (current is INamespaceSymbol ns)
        {
            if (!ns.IsGlobalNamespace) parts.Push(ns.ToDisplayString());
        }

        return string.Join(".", parts);
    }

/* -----------------------------------------------------------------
OVERRIDES                                                          |
----------------------------------------------------------------- */

    protected abstract void EmitNestedClassBoilerplate(StringBuilder builder, string[] nested_names, List<(string Name, string Type)> properties);
}
