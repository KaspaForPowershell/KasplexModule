namespace PWSH.Kasplex.SourceGenerators.Generators;

public abstract class AbstractBoilerplateGenerator
    :
    IIncrementalGenerator
{
    protected readonly string _attributeNamespace = "PWSH.Kasplex.SourceGenerators.Attributes";
    protected readonly string _attributeName;
    protected readonly string _attributeFileName;

    protected readonly Dictionary<string, uint> COUNT_PER_FILE = [];

/* -----------------------------------------------------------------
CONSTRUCTORS                                                       |
----------------------------------------------------------------- */

    public AbstractBoilerplateGenerator(string attribute_name)
    {
        this._attributeName = attribute_name;
        this._attributeFileName = $"{this._attributeNamespace}.{this._attributeName}";
    }

/* -----------------------------------------------------------------
HELPERS                                                            |
----------------------------------------------------------------- */

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider
        (
            predicate: static (node, _) => IsSyntaxTarget(node),
            transform: (gtx, _) => GetSymanticTarget(gtx)
        );
        //.Where(static target => target.Ok is not null);

        context.RegisterSourceOutput(provider, (ctx, source) => Execute(ctx, source));
        context.RegisterPostInitializationOutput(ctx => PostInitializationOutput(ctx));
    }

    protected static bool IsSyntaxTarget(SyntaxNode node)
        => node is ClassDeclarationSyntax classNode && classNode.AttributeLists.Count > 0;

    private static bool IsPartial(INamedTypeSymbol classSymbol)
        => classSymbol.DeclaringSyntaxReferences
                      .Select(r => r.GetSyntax())
                      .OfType<ClassDeclarationSyntax>()
                      .Any(c => c.Modifiers.Any(SyntaxKind.PartialKeyword));

    protected (Diagnostic? Err, DataContainer? Ok) GetSymanticTarget(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);
        var attributeSymbol = context.SemanticModel.Compilation.GetTypeByMetadataName(this._attributeFileName);

        if (classSymbol is null || attributeSymbol is null) return (null, null);

        foreach (var data in classSymbol.GetAttributes())
        {
            if (!attributeSymbol.Equals(data.AttributeClass, SymbolEqualityComparer.Default)) continue;

            if (!IsPartial(classSymbol))
            {
                var diagnostic = Diagnostic.Create
                (
                    new DiagnosticDescriptor
                    (
                        id: "GEN001",
                        title: "Class must be partial",
                        messageFormat: "The class '{0}' must be marked partial to use '{1}'",
                        category: "SourceGeneration",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true
                    ),
                    classSymbol.Locations.FirstOrDefault(),
                    classSymbol.Name,
                    this._attributeName
                );

                return (diagnostic, null);
            }

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = GetFullMetadataName(classSymbol);

#pragma warning disable IDE0037 // Use inferred member name.
            var properties = classSymbol.GetMembers()
                        .OfType<IPropertySymbol>()
                        .Where(p => p.DeclaredAccessibility == Accessibility.Public)
                        .Select(p => (p.Name, Type: p.Type.ToDisplayString()))
                        .ToList();
#pragma warning restore IDE0037 // Use inferred member name.

            return (null, new DataContainer(namespaceName, className, properties));
        }

        return (null, null);
    }

    protected void Execute(SourceProductionContext context, (Diagnostic? Err, DataContainer? Ok) data)
    {
        if (data.Err is not null)
        {
            context.ReportDiagnostic(data.Err);
            return;
        }

        if (data.Ok is null) return;

        var namespaceName = data.Ok.NamespaceName;
        var className = data.Ok.ClassName;
        var fileName = $"{namespaceName}.{className}.g.cs";

        if (!COUNT_PER_FILE.ContainsKey(fileName)) COUNT_PER_FILE.Add(fileName, 0);
        COUNT_PER_FILE[fileName]++;

        var builder = new StringBuilder()
            .AppendLine("// <auto-generated />")
            .AppendLine($"// Generation count: {COUNT_PER_FILE[fileName]}")
            .AppendLine("#nullable enable")
            .AppendLine()
            .Append($"namespace {namespaceName};").AppendLine()
            .AppendLine();

        var nestedClassNames = className.Split('.');
        EmitNestedClassBoilerplate(builder, nestedClassNames, [.. data.Ok.PropertyInfos]);

        context.AddSource(fileName, builder.ToString());
    }

    protected void PostInitializationOutput(IncrementalGeneratorPostInitializationContext context)
    {
        var builder = new StringBuilder()
            .Append($"namespace {this._attributeNamespace};").AppendLine()
            .AppendLine()
            .Append("[AttributeUsage(AttributeTargets.Class)]").AppendLine()
            .Append($"internal class {this._attributeName}").AppendLine()
            .AppendIndent(1).Append(":").AppendLine()
            .AppendIndent(1).Append("System.Attribute {}");

        context.AddSource
        (
            $"{this._attributeFileName}.g.cs",
            builder.ToString()
        );
    }

    protected static string GetFullMetadataName(INamedTypeSymbol type_symbol)
    {
        var parts = new Stack<string>();
        ISymbol? current = type_symbol;

        while (current is INamedTypeSymbol namedType)
        {
            parts.Push(namedType.Name);
            current = namedType.ContainingType;
        }

        if (current is INamespaceSymbol ns)
        {
            if (!ns.IsGlobalNamespace) parts.Push(ns.ToDisplayString());
        }

        return string.Join(".", parts);
    }

/* -----------------------------------------------------------------
OVERRIDES                                                          |
----------------------------------------------------------------- */

    protected abstract void EmitNestedClassBoilerplate(StringBuilder builder, string[] nested_names, List<(string Name, string Type)> properties);
}
